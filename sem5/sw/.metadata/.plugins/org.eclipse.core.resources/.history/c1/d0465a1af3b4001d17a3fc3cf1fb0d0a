/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file    stm32l4xx_it.c
 * @brief   Interrupt Service Routines.
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32l4xx_it.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define JOY_PORT GPIOE

#define JOY_PORT_RIGHT GPIO_PIN_0
#define JOY_PORT_LEFT GPIO_PIN_1
#define JOY_PORT_UP GPIO_PIN_3
#define JOY_PORT_DOWN GPIO_PIN_2
#define JOY_PORT_PUSH GPIO_PIN_15

#define IS_JOY_LEFT ((~(GPIOE->IDR) & JOY_PORT_LEFT) ? 1 : 0)
#define IS_JOY_RIGHT ((~(GPIOE->IDR) & JOY_PORT_RIGHT) ? 1 : 0)
#define JOY_UP_STATE ((~(GPIOE->IDR) & JOY_PORT_UP) ? 1 : 0)
#define JOY_DOWN_STATE ((~(GPIOE->IDR) & JOY_PORT_DOWN) ? 1 : 0)
#define JOY_PUSH_STATE ((~(GPIOE->IDR) & JOY_PORT_PUSH) ? 1 : 0)

#define LED0 GPIOD, GPIO_PIN_12
#define LED1 GPIOD, GPIO_PIN_13
#define LED2 GPIOB, GPIO_PIN_8

#define FREQ 50
#define TIME 1000 //ms
#define DELAY TIME / FREQ //period (ms)
#define NUMBER_OF_LEDS 3U
#define MAX_LED_LVL DELAY
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

uint8_t was_joy_left = 0U;
uint8_t was_joy_right = 0U;
uint8_t was_joy_up = 0U;
uint8_t was_joy_down = 0U;

uint8_t cntr = 0U;
uint8_t leds_lvl[NUMBER_OF_LEDS] = { 0U };
uint8_t cur_led = 0U;

uint8_t is_blink_time;
uint8_t joy_pushed = 1;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/

/* USER CODE BEGIN EV */

/* USER CODE END EV */

/******************************************************************************/
/*           Cortex-M4 Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
 * @brief This function handles Non maskable interrupt.
 */
void NMI_Handler(void) {
	/* USER CODE BEGIN NonMaskableInt_IRQn 0 */

	/* USER CODE END NonMaskableInt_IRQn 0 */
	/* USER CODE BEGIN NonMaskableInt_IRQn 1 */
	while (1) {
	}
	/* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
 * @brief This function handles Hard fault interrupt.
 */
void HardFault_Handler(void) {
	/* USER CODE BEGIN HardFault_IRQn 0 */

	/* USER CODE END HardFault_IRQn 0 */
	while (1) {
		/* USER CODE BEGIN W1_HardFault_IRQn 0 */
		/* USER CODE END W1_HardFault_IRQn 0 */
	}
}

/**
 * @brief This function handles Memory management fault.
 */
void MemManage_Handler(void) {
	/* USER CODE BEGIN MemoryManagement_IRQn 0 */

	/* USER CODE END MemoryManagement_IRQn 0 */
	while (1) {
		/* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
		/* USER CODE END W1_MemoryManagement_IRQn 0 */
	}
}

/**
 * @brief This function handles Prefetch fault, memory access fault.
 */
void BusFault_Handler(void) {
	/* USER CODE BEGIN BusFault_IRQn 0 */

	/* USER CODE END BusFault_IRQn 0 */
	while (1) {
		/* USER CODE BEGIN W1_BusFault_IRQn 0 */
		/* USER CODE END W1_BusFault_IRQn 0 */
	}
}

/**
 * @brief This function handles Undefined instruction or illegal state.
 */
void UsageFault_Handler(void) {
	/* USER CODE BEGIN UsageFault_IRQn 0 */

	/* USER CODE END UsageFault_IRQn 0 */
	while (1) {
		/* USER CODE BEGIN W1_UsageFault_IRQn 0 */
		/* USER CODE END W1_UsageFault_IRQn 0 */
	}
}

/**
 * @brief This function handles System service call via SWI instruction.
 */
void SVC_Handler(void) {
	/* USER CODE BEGIN SVCall_IRQn 0 */

	/* USER CODE END SVCall_IRQn 0 */
	/* USER CODE BEGIN SVCall_IRQn 1 */

	/* USER CODE END SVCall_IRQn 1 */
}

/**
 * @brief This function handles Debug monitor.
 */
void DebugMon_Handler(void) {
	/* USER CODE BEGIN DebugMonitor_IRQn 0 */

	/* USER CODE END DebugMonitor_IRQn 0 */
	/* USER CODE BEGIN DebugMonitor_IRQn 1 */

	/* USER CODE END DebugMonitor_IRQn 1 */
}

/**
 * @brief This function handles Pendable request for system service.
 */
void PendSV_Handler(void) {
	/* USER CODE BEGIN PendSV_IRQn 0 */

	/* USER CODE END PendSV_IRQn 0 */
	/* USER CODE BEGIN PendSV_IRQn 1 */

	/* USER CODE END PendSV_IRQn 1 */
}

/**
 * @brief This function handles System tick timer.
 */
void SysTick_Handler(void) {
	/* USER CODE BEGIN SysTick_IRQn 0 */

	/* USER CODE END SysTick_IRQn 0 */
	HAL_IncTick();
	/* USER CODE BEGIN SysTick_IRQn 1 */

	is_blink_time = DELAY == cntr;
	joy_pushed = was_joy_up || was_joy_down || was_joy_left || was_joy_right;

	if (is_blink_time && JOY_UP_STATE && !joy_pushed) {
		if (leds_lvl[cur_led] < MAX_LED_LVL) {
			leds_lvl[cur_led] += 1U;
		} else {
			leds_lvl[cur_led] = MAX_LED_LVL;
		}
		was_joy_up = 1U;
	}

	if (is_blink_time && JOY_DOWN_STATE && !joy_pushed) {
		if (leds_lvl[cur_led] > 0U) {
			leds_lvl[cur_led] -= 1U;
		} else {
			leds_lvl[cur_led] = 0U;
		}
		was_joy_down = 1U;
	}

	if (is_blink_time && IS_JOY_LEFT && !joy_pushed) {
		if (0U == was_joy_left) {
			if (cur_led > 0U) {
				cur_led--;
			} else {
				cur_led = NUMBER_OF_LEDS - 1U;
			}
		}
		was_joy_left = 1U;
	}
	if (is_blink_time && IS_JOY_RIGHT && !joy_pushed) {
		if (0U == was_joy_right) {
			if (cur_led < (NUMBER_OF_LEDS - 1U)) {
				cur_led++;
			} else {
				cur_led = 0U;
			}
		}
		was_joy_right = 1U;
	}

	if (is_blink_time && JOY_PUSH_STATE && !joy_pushed) {
		leds_lvl[0U] = 0U;
		leds_lvl[1U] = 0U;
		leds_lvl[2U] = 0U;

		joy_pushed = 1;
	}

	if (is_blink_time) {
		cntr = 0U;
	}

	if (!IS_JOY_RIGHT && !IS_JOY_LEFT && !JOY_DOWN_STATE && !JOY_UP_STATE) {
		joy_pushed = 0;
		was_joy_right = 0;
		was_joy_left = 0;
		was_joy_up = 0;
		was_joy_down = 0;
	}

	if (!is_blink_time) {
		cntr++;
	}

	if (cntr < leds_lvl[0U]) {
		HAL_GPIO_WritePin(LED0, GPIO_PIN_SET);
	} else {
		HAL_GPIO_WritePin(LED0, GPIO_PIN_RESET);
	}

	if (cntr < leds_lvl[1U]) {
		HAL_GPIO_WritePin(LED1, GPIO_PIN_SET);
	} else {
		HAL_GPIO_WritePin(LED1, GPIO_PIN_RESET);
	}

	if (cntr < leds_lvl[2U]) {
		HAL_GPIO_WritePin(LED2, GPIO_PIN_SET);
	} else {
		HAL_GPIO_WritePin(LED2, GPIO_PIN_RESET);
	}

	/* USER CODE END SysTick_IRQn 1 */
}

/******************************************************************************/
/* STM32L4xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32l4xx.s).                    */
/******************************************************************************/

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
